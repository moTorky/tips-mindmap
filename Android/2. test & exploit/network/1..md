#### detect if app use network
1. use the app, and analysis it's functions
2. look for `ACCESS_NETWORK_STATE`permission in AnadroidManifest.xml 
3. grep for http connection keywords and classes: `HttpsURLConnection`, `HTTPS`, background threads using `AsyncTask` class 
#### what we look for when analyzing app's network
- What is the data that is being exchanged? and  Is the data in clear text?
- What is the Communication channel? are it secure?
- Is any of the data of a private or sensitive nature?
#### how to analyze
##### apps target API Level 23 and before
1. static code analysis: try to map the app
    and find out how developer verify cert or search following:
    1. create `X509TrustManager` that doesn’t return any certificate warnings. by implement `getAcceptedIssuers` method to return`null` or not implement `checkServerTrusted` method
    2. ignore that DNS hostname doesn’t match any allowed values on the certificate. `SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER`, or make verify method `return true`
2. dynamic analysis:
    1. set burp proxy to listen on mobile’s wireless network. certificate tap allow you to configure certificate returned for HTTPS traffic:
        1. generate new certificate, to match any domain signed by “portwigger” CA
        2. generate new certificate, to match specific hostname
    2. some devices doesn’t allow proxy, in this case u gonna need to perform MITM

##### apps target API Level 24+ using NSC (network security config)
1. patch the app 
	1. Decode the app using `apktool`
	2. introduce a `network_security_config.xml` file at `res/xml/`
	3. add the self-signed or burp CA cert, in PEM or DER format to `res/raw/<name>`
	4. repackage and sign

	- [ ] test if the app perform hostname validation: generate new certificate, with hostname `attaker.com` place it to step3 above. if burp intercept any HTTPS traffic to other hosts (not `attaker.com`) then the app not perform hostname validation.
	    
	    explain: burp return `attaker.com` in certificate’s CN, and the app still make HTTPS to `target.com` so an attacker can sign there own certificate for attacker.com to CA that listed in `network_security_config.xml` file, ARP spoof the victim, response with the signed certificate for the requested domain, and view encrypted traffic.
1. use run time manipulation tool such `Frida`
#### expand attack surface
we can split the app into four areas 
1. remote server: where we can look for web server/webApp vulns
2. communication channel: capture, intercept and modify exchanged data 
3. Network  components: find entry and exit points for exchanged data 
4. Processing  Layer: where we trace the data flow and identify how and where the app use data 
##### review web section for scan exploit remote server
##### exploit Network Traffic vulns (communication channel)
attackers/testers can exploit following by use MITM(ARP spoof) attack, or DNS spoof. to route the user to use their network
1. for first check(hostname validation), they can sign there own certificate for `attacker.com` to CA that trusted by user device, ARP spoof the victim, response with the signed certificate to view encrypted traffic.
    - [ ] this test can done by generate burp certificate and install it on testing device, set burp to generate new certificate, to `attacker.com` hostname
2. if the app not validated CA signing the certificate, attacker can use self signed certificate (burp can generate one) no need to sign one like above case
    - [ ] before u install burp certificate and after setup proxy setting, check if any HTTPS requests captured in proxy tap; if so then app vuln. cuz “portwigger” CA not in device’s trusted CA list, and burp was able to capture HTTPS requests


----
#### bypass certificate pinning
##### static and app patching
###### default
to bypass certificate pinning, u can simply patch the app by modify `smali` code:
1.  search for “X509TrustManager” returns one class that implements a custom TrustManager. The derived class implements the methods `checkClientTrusted`, `checkServerTrusted`, and `getAcceptedIssuers`. 
2. add the `return-void` opcode to the first line of each method
###### Custom Certificate Pinning
- Certificate hashes: `grep -ri "sha256\|sha1" ./smali`. Replace the identified hashes with the hash of your proxy’s CA. Alternatively, if the hash is accompanied by a domain name, you can try modifying the domain name to a non- existing domain so that the original domain is not pinned. This works well on obfuscated `OkHTTP` implementations. 
- Certificate files: `find ./assets -type f \( -iname \*.cer -o -iname \*.crt \)`. Replace these files with your proxy’s certificates, making sure they are in the correct format. 
- Truststore files: `find ./ -type f \( -iname \*.jks -o -iname \*.bks \)`. Add your proxy’s certificates to the truststore and make sure they are in the correct format.
- review this blog for [bypassing-native-ssl-pinning-in-android-applications](https://serializethoughts.wordpress.com/2016/08/18/bypassing-ssl-pinning-in-android-applications/)
##### Dynamic 
###### default
if the app uses the API functions that are covered by these tools, then it can be bypassed in seconds, but if app use custom library then must be manually patched and deactivated.
- Cydia Substrate: Install the [Android-SSL-TrustKiller](https://github.com/iSECPartners/Android-SSL-TrustKiller) package.
- Frida: Use the frida-multiple-unpinning script. 
- Objection: Use `android sslpinning disable` command on rooted device or repackage the app in non-rooted device
- Xposed: Install the `TrustMeAlready` or `SSLUnpinning` module.
###### Custom Certificate Pinning
1. identify used library; search for common library such `OkHTTP3`
2. review it's documentation to find pinning method name, 
3. or Search for hashes and domain names using `grep` on source code
4. or Hook each method with Frida and print the arguments. One of them will print out a domain name and a certificate hash
5. hock and modify arguments to pinning function 